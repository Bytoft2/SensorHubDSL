/*
 * generated by Xtext 2.25.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.sensorHub.Com
import org.xtext.example.mydsl.sensorHub.Edge
import org.xtext.example.mydsl.sensorHub.Fog
import org.xtext.example.mydsl.sensorHub.Nrf24l01
import org.xtext.example.mydsl.sensorHub.RaspPi
import org.xtext.example.mydsl.sensorHub.SensorSystem
import org.xtext.example.mydsl.sensorHub.Arduino
import org.xtext.example.mydsl.sensorHub.Sensor
import org.xtext.example.mydsl.sensorHub.Average
import org.xtext.example.mydsl.sensorHub.Threshold
import org.xtext.example.mydsl.sensorHub.Sr04
import org.xtext.example.mydsl.sensorHub.Water_level
import org.xtext.example.mydsl.sensorHub.Sound

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SensorHubGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val modelInstance = resource.allContents.filter(SensorSystem).next
		modelInstance.devices.filter(Fog).forEach[generateFogFile(fsa)]
		modelInstance.devices.filter(Fog).forEach[generateEdgeFiles(fsa)]
	}
	
	def generateEdgeFiles(Fog fog, IFileSystemAccess2 fsa) {
		for(e:fog.edgeDevices){
			switch e.device {
				Arduino: 
					fsa.generateFile("./"+fog.name+"/Edges/"+e.name+"/"+e.name+".ino", e.generateArduino(fog.coms))
			}
		}
	}
	
	def generateFogFile(Fog fog, IFileSystemAccess2 fsa) {
		switch fog.device {
			RaspPi: 
				fsa.generateFile("./"+fog.name+"/"+fog.name+".py", fog.generateRaspPi)
		}
	}
	
	def CharSequence generateRaspPi(Fog pi) '''
	import time
	import struct
	import board
	import digitalio
	
	#Setup of communication
	«generatePythonComSetup(pi.coms, pi.edgeDevices)»
	
	#Reciever function
	«generateReceiverFunction(pi.coms)»
	
	
	#Edge device storage and viz code: 

	«FOR s:pi.device.storage»
		«IF s.type == "txt"»
			«generatePythonStorageTxt()»
		«ENDIF»

	«ENDFOR»
	«FOR v:pi.device.visualization»
		«IF v.type == "console"»
			«generatePythonVizConsole()»
		«ENDIF»
	«ENDFOR»
	'''
	
	def dispatch CharSequence generateReceiverFunction(Fog f) '''
	'''
	
	def dispatch CharSequence generateReceiverFunction(Nrf24l01 nrf) '''
	def receive(timeout=«nrf.timeout»):
		"""Polls the radio and prints the received value. This method expires
		after if no transmission is recieved within the timeout"""
		
		# put radio into RX mode and power up
		nrf.listen = True
		
		start = time.monotonic()
		while (time.monotonic() - start) < timeout:
		    if nrf.available():
		        # grab information about the received payload
		        payload_size, pipe_number = (nrf.any(), nrf.pipe)
		        
		        # fetch 1 payload from RX FIFO
		        buffer = nrf.read()  # also clears nrf.irq_dr status flag
		        
		        # format string "<f"
		        # buffer[:4] truncates padded 0s if dynamic payloads are disabled
		        payload[0] = struct.unpack("<f", buffer[:4])[0]
		        
		        # print details about the received packet
		        timestamp = time.time()
		        save(addresses[pipe_number-1], timestamp, payload[0])
		        
		        visualize(addresses[pipe_number-1], timestamp, payload[0])
		        start = time.monotonic()
		        
		# recommended behavior is to keep in TX mode while idle
		nrf.listen = False  # put the nRF24L01 is in TX mode
	'''	
	
	def CharSequence generatePythonComSetup(Com c, EList<Edge> edges) '''
	from circuitpython_nrf24l01.rf24 import RF24
	
	# digital output pins
	ce = digitalio.DigitalInOut(board.D4)
	csn = digitalio.DigitalInOut(board.D5)
	
	# init spi bus object
	spi = board.SPI()  
	
	# initialize the nRF24L01 on the spi bus object
	nrf = RF24(spi, csn, ce)
	
	# set power amplifier level (RF24_PA_MIN, RF24_PA_LOW, RF24_PA_MED, RF24_PA_HIGH)
	nrf.pa_level = RF24_PA_LOW
	
	# addresses needs to be in a buffer protocol object (bytearray)
	addresses = [«FOR e:edges SEPARATOR ','»b"«e.name»"«ENDFOR»]
	
	# set RX address of TX node into RX pipes
	«FOR i : 1..edges.size»
	nrf.open_rx_pipe(«i», address[«i»])  # using pipe «i»
	«ENDFOR»
	
	# list to store float number for the payloads sent
	payload = [0.0]
	
	# for compatibility with TMRh20 library
	nrf.allow_ask_no_ack = False
	nrf.dynamic_payloads = False
	nrf.payload_length = 32
	'''
	
	def CharSequence generatePythonStorageTxt() '''
	def saveTxt(addr, timestamp, value):
		with open("./" + str(addr) + ".txt", "a") as f:
	            f.write(str(timestamp) + ", " + str(value) + "\n")
	'''
	
	def CharSequence generatePythonVizConsole() '''
	def toConsole(addr, timestamp, value):
		print(str(addr) + ": " + str(timestamp) + ", " + str(value))
	'''
	
	def CharSequence generateArduino(Edge ino, Com coms) '''
	//Send.ino
	#include<SPI.h>
	«ino.generateInoComsImports(coms)»
	«FOR s:ino.device.sensors»
	«generateInoSensorImports(s)»
	«ENDFOR»
	
	void setup(void){
	«generateInoComsSetup(coms)»
	}
	
	void loop(void){
		int sendTime = millis() + «ino.device.rate»;
		«FOR s:ino.device.sensors»
		«generateInoSensorVars(s, s.preprocessor)»
		«ENDFOR»
		while(sendTime >= millis()){
		«FOR s:ino.device.sensors»
		read«s.name»(temp«s.name»)
		«generateInoSensorRead(s)»
		«ENDFOR»
		delay(1);
		}
		«FOR s:ino.device.sensors»
		«generateInoSensorProc(s, s.preprocessor)»
		radio.write(final«s.name», sizeof(final«s.name»));
		«ENDFOR»
		delay(1);
	}
	'''
	
	def dispatch CharSequence generateInoSensorImports(Sound s) '''
	int «s.name»AnalogPin = 1;
	'''
	
	def dispatch CharSequence generateInoSensorImports(Water_level s) '''
	int «s.name»AnalogPin = 0;
	'''
	
	def dispatch CharSequence generateInoSensorImports(Sr04 s) '''
	#include "SR04.h"
	
	#define «s.name»TRIG_PIN 12
	#define «s.name»ECHO_PIN 11
	SR04 sr04 = SR04(«s.name»ECHO_PIN, «s.name»TRIG_PIN);
	'''
	
	def dispatch CharSequence generateInoSensorProc(Sensor s, Threshold th) '''
	final«s.name» = temp«s.name»
	'''
	
	def dispatch CharSequence generateInoSensorProc(Sensor s, Average th) '''
	final«s.name» = temp«s.name» / count«s.name»
	'''
	
	def dispatch CharSequence generateInoSensorRead(Sound s) '''
	static void read«s.name»( float *temp)
	{
		static unsigned long measurement_timestamp = millis( );
	
		/* Measure once every four seconds. */
		if( millis( ) - measurement_timestamp > «s.rate»ul )
		{
			temp = analogRead(«s.name»AnalogPin)
	  	}
	}
	'''
	
	def dispatch CharSequence generateInoSensorRead(Water_level s) '''
	static void read«s.name»( float *temp)
	{
		static unsigned long measurement_timestamp = millis( );
	
		/* Measure once every four seconds. */
		if( millis( ) - measurement_timestamp > «s.rate»ul )
		{
			temp = analogRead(«s.name»AnalogPin)
	  	}
	}
	'''
	
	def dispatch CharSequence generateInoSensorRead(Sr04 s) '''
	static void read«s.name»( float *temp)
	{
		static unsigned long measurement_timestamp = millis( );
	
		/* Measure once every four seconds. */
		if( millis( ) - measurement_timestamp > «s.rate»ul )
		{
			temp = sr04.Distance()
	  	}
	}	
	'''
	
	def dispatch CharSequence generateInoSensorVars(Sensor s, Threshold th) '''
		float temp«s.name»;
		float final«s.name»;
		int min«s.name» = «th.min»;
		int max«s.name» = «th.max»;
	'''
	
	def dispatch CharSequence generateInoSensorVars(Sensor s, Average a)'''
		float temp«s.name» = 0.0;
		float final«s.name» = 0.0;
		int count«s.name» = 0;
	'''
	
	def dispatch CharSequence generateInoComsImports(Edge e, Edge _) '''
	
	'''
	
	def dispatch CharSequence generateInoComsImports(Edge e, Nrf24l01 nrf) '''
	#include<RF24.h>
	
	// ce, csn pins
	RF24 radio(9, 10);
	uint8_t address = "«e.name»";
	'''
	
	def dispatch CharSequence generateInoComsSetup(Edge _) '''
	
	'''
	
	def dispatch CharSequence generateInoComsSetup(Nrf24l01 nrf) '''
	radio.begin();
	radio.setPALevel(RF24_PA_LOW);
	radio.openWritingPipe(address);
	radio.setPayloadSize(32);
	radio.powerUp();
	'''
}
