/*
 * generated by Xtext 2.25.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.sensorHub.*
import org.xtext.example.mydsl.sensorHub.RaspPi
import org.xtext.example.mydsl.sensorHub.Edge
import org.eclipse.emf.common.util.EList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SensorHubGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val modelInstance = resource.allContents.filter(SensorSystem).next
		modelInstance.devices.filter(Fog).forEach[generateFogFile(fsa)]
	}
	
	def generateFogFile(Fog fog, IFileSystemAccess2 fsa) {
		switch fog {
			RaspPi: 
				fsa.generateFile("./"+fog.name+"/"+fog.name+".py", fog.generateRaspPi)
				//TODO Generate storage file on pi
		}
	}
	
	def CharSequence generateRaspPi(Fog pi) '''
	import time
	import struct
	import board
	import digitalio
	
	#Setup of communication
	«generateComSetup(pi.coms, pi.edgeDevices)»
	
	#Reciever function
	«generateReceiverFunction(pi.coms)»
	
	
	#Edge device storage and viz code: 

	«FOR s:pi.device.storage»
		«IF s.type == "txt"»
			«generateStorageTxt()»
		«ENDIF»

	«ENDFOR»
	«FOR v:pi.device.visualization»
		«IF v.type == "console"»
			«generateVizConsole()»
		«ENDIF»
	«ENDFOR»
	'''
	
	def dispatch CharSequence generateReceiverFunction(Fog f) '''
	'''
	
	def dispatch CharSequence generateReceiverFunction(Nrf24l01 nrf, EList<Edge> edges) '''
	def receive(timeout=«nrf.timeout»):
		"""Polls the radio and prints the received value. This method expires
		after if no transmission is recieved within the timeout"""
		
		# put radio into RX mode and power up
		nrf.listen = True
		
		start = time.monotonic()
		while (time.monotonic() - start) < timeout:
		    if nrf.available():
		        # grab information about the received payload
		        payload_size, pipe_number = (nrf.any(), nrf.pipe)
		        
		        # fetch 1 payload from RX FIFO
		        buffer = nrf.read()  # also clears nrf.irq_dr status flag
		        
		        # format string "<f"
		        # buffer[:4] truncates padded 0s if dynamic payloads are disabled
		        payload[0] = struct.unpack("<f", buffer[:4])[0]
		        
		        # print details about the received packet
		        timestamp = time.time()
		        save(timestamp, payload[0])
		        
		        visualize(timestamp, payload[0])
		        start = time.monotonic()
		        
		# recommended behavior is to keep in TX mode while idle
		nrf.listen = False  # put the nRF24L01 is in TX mode
	'''	
	
	def CharSequence generateComSetup(Com c, EList<Edge> edges) '''
	from circuitpython_nrf24l01.rf24 import RF24
	
	# digital output pins
	ce = digitalio.DigitalInOut(board.D4)
	csn = digitalio.DigitalInOut(board.D5)
	
	# init spi bus object
	spi = board.SPI()  
	
	# initialize the nRF24L01 on the spi bus object
	nrf = RF24(spi, csn, ce)
	
	# set power amplifier level (RF24_PA_MIN, RF24_PA_LOW, RF24_PA_MED, RF24_PA_HIGH)
	nrf.pa_level = RF24_PA_LOW
	
	# addresses needs to be in a buffer protocol object (bytearray)
	addresses = [«FOR e:edges SEPARATOR ','»b"«e.name»"«ENDFOR»]
	
	# set RX address of TX node into RX pipes
	«FOR i : 1..edges.size»
	nrf.open_rx_pipe(i, address[i])  # using pipe i
	«ENDFOR»
	
	# list to store float number for the payloads sent
	payload = [0.0]
	
	# for compatibility with TMRh20 library
	nrf.allow_ask_no_ack = False
	nrf.dynamic_payloads = False
	nrf.payload_length = 32
	'''
	
	def CharSequence generateStorageTxt() '''
	def saveTxt(addr, timestamp, value):
		with open("./" + str(addr) + ".txt", "a") as f:
	            f.write(str(timestamp) + ", " + str(value) + "\n")
	'''
	
	def CharSequence generateVizConsole() '''
	def toConsole(addr, timestamp, value):
		print(str(addr) + ": " + str(timestamp) + ", " + str(value))
	'''
	
	
}
