/*
 * generated by Xtext 2.25.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.sensorHub.Com
import org.xtext.example.mydsl.sensorHub.Edge
import org.xtext.example.mydsl.sensorHub.Fog
import org.xtext.example.mydsl.sensorHub.Nrf24l01
import org.xtext.example.mydsl.sensorHub.RaspPi
import org.xtext.example.mydsl.sensorHub.SensorSystem
import org.xtext.example.mydsl.sensorHub.Arduino

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SensorHubGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val modelInstance = resource.allContents.filter(SensorSystem).next
		modelInstance.devices.filter(Fog).forEach[generateFogFile(fsa)]
		modelInstance.devices.filter(Edge).forEach[generateEdgeFile(fsa)]
	}
	
	def generateEdgeFile(Edge edge, IFileSystemAccess2 fsa) {
		switch edge {
			Arduino: 
				fsa.generateFile("./Edge/"+edge.name+".ino", edge.generateArduino)
		}
	}
	
	def generateFogFile(Fog fog, IFileSystemAccess2 fsa) {
		switch fog.device {
			RaspPi: 
				fsa.generateFile("./"+fog.name+"/"+fog.name+".py", fog.generateRaspPi)
		}
	}
	
	def CharSequence generateRaspPi(Fog pi) '''
	import time
	import struct
	import board
	import digitalio
	
	#Setup of communication
	«generatePythonComSetup(pi.coms, pi.edgeDevices)»
	
	#Reciever function
	«generateReceiverFunction(pi.coms)»
	
	
	#Edge device storage and viz code: 

	«FOR s:pi.device.storage»
		«IF s.type == "txt"»
			«generatePythonStorageTxt()»
		«ENDIF»

	«ENDFOR»
	«FOR v:pi.device.visualization»
		«IF v.type == "console"»
			«generatePythonVizConsole()»
		«ENDIF»
	«ENDFOR»
	'''
	
	def dispatch CharSequence generateReceiverFunction(Fog f) '''
	'''
	
	def dispatch CharSequence generateReceiverFunction(Nrf24l01 nrf) '''
	def receive(timeout=«nrf.timeout»):
		"""Polls the radio and prints the received value. This method expires
		after if no transmission is recieved within the timeout"""
		
		# put radio into RX mode and power up
		nrf.listen = True
		
		start = time.monotonic()
		while (time.monotonic() - start) < timeout:
		    if nrf.available():
		        # grab information about the received payload
		        payload_size, pipe_number = (nrf.any(), nrf.pipe)
		        
		        # fetch 1 payload from RX FIFO
		        buffer = nrf.read()  # also clears nrf.irq_dr status flag
		        
		        # format string "<f"
		        # buffer[:4] truncates padded 0s if dynamic payloads are disabled
		        payload[0] = struct.unpack("<f", buffer[:4])[0]
		        
		        # print details about the received packet
		        timestamp = time.time()
		        save(addresses[pipe_number-1], timestamp, payload[0])
		        
		        visualize(addresses[pipe_number-1], timestamp, payload[0])
		        start = time.monotonic()
		        
		# recommended behavior is to keep in TX mode while idle
		nrf.listen = False  # put the nRF24L01 is in TX mode
	'''	
	
	def CharSequence generatePythonComSetup(Com c, EList<Edge> edges) '''
	from circuitpython_nrf24l01.rf24 import RF24
	
	# digital output pins
	ce = digitalio.DigitalInOut(board.D4)
	csn = digitalio.DigitalInOut(board.D5)
	
	# init spi bus object
	spi = board.SPI()  
	
	# initialize the nRF24L01 on the spi bus object
	nrf = RF24(spi, csn, ce)
	
	# set power amplifier level (RF24_PA_MIN, RF24_PA_LOW, RF24_PA_MED, RF24_PA_HIGH)
	nrf.pa_level = RF24_PA_LOW
	
	# addresses needs to be in a buffer protocol object (bytearray)
	addresses = [«FOR e:edges SEPARATOR ','»b"«e.name»"«ENDFOR»]
	
	# set RX address of TX node into RX pipes
	«FOR i : 1..edges.size»
	nrf.open_rx_pipe(«i», address[«i»])  # using pipe «i»
	«ENDFOR»
	
	# list to store float number for the payloads sent
	payload = [0.0]
	
	# for compatibility with TMRh20 library
	nrf.allow_ask_no_ack = False
	nrf.dynamic_payloads = False
	nrf.payload_length = 32
	'''
	
	def CharSequence generatePythonStorageTxt() '''
	def saveTxt(addr, timestamp, value):
		with open("./" + str(addr) + ".txt", "a") as f:
	            f.write(str(timestamp) + ", " + str(value) + "\n")
	'''
	
	def CharSequence generatePythonVizConsole() '''
	def toConsole(addr, timestamp, value):
		print(str(addr) + ": " + str(timestamp) + ", " + str(value))
	'''
	
	def CharSequence generateArduino() '''
	//Send.ino
	#include<SPI.h>
	#include<RF24.h>
	// ce, csn pins
	RF24 radio(9, 10);
	uint8_t addresses[][6] = {"1Node", "2Node"};
	
	void setup(void){
	  Serial.begin(9600);
	  radio.begin();
	  radio.setPALevel(RF24_PA_MIN);
	  radio.openWritingPipe(addresses[1]);
	  radio.setPayloadSize(32);
	  radio.powerUp();
	}
	
	void loop(void){
	  const char text[] = "Hello World is awesome";
	  Serial.write(text);
	  radio.write(text, sizeof(text));
	  delay(1000);
	}
	'''
	
}
